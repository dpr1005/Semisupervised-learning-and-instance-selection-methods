\apendice{Documentación de usuario}

\section{Introducción}
En esta sección se detallan los requerimientos de la aplicación, su instalación y despliegue (en el caso de \texttt{UBUMLaaS}) y se acompañan de una serie de indicaciones y consejos para su correcto uso.

De igual manera que en el Manual del Programador cada parte del proyecto, \texttt{IS-SSL} y \texttt{UBUMLaaS}, se describirá por su propio lado, de tal manera que aunque haya aspectos comunes, cada una su propia documentación de usuario.

\section{UBUMLaaS}
\subsection{Requisitos de usuarios}
Los requisitos mínimos para poder hacer uso de \texttt{UBUMLaaS} son:
\begin{itemize}
\item Disponer de una conexión a Internet.
\item Hacer uso de navegador web con soporte a HTML5.
\item Tener habilitado JavaScript en el navegador.
\item Tener una cuenta en la plataforma.
\end{itemize}
\subsection{Instalación}
Al tratarse de un producto web no se requiere de ningún tipo de instalación. Los navegadores Google Chrome, Mozilla Firefox, Safari y Microsfot Edge son soportados\footnote{Todos ellos han sido probados por el equipo de desarrollo y usuarios encuestados a  los que se les proporcionó un documento de uso básico y lo usaron en sus dispositivos cotidianos.}, siempre y cuando se encuentren en versiones compatibles con HTML5 y tengan activado el uso de JavaScript.

Independientemente del dispositivo de uso (ordenador de sobremesa, portátil, tableta o móvil), se requiere de conexión a Internet como es lógico. Pero no necesita de permisos adicionales, ha sido desarrollada de tal manera que utiliza la sesión local del navegador sin necesidad del uso de \textit{cookies}.

Aunque se hizo un intento de traducción a los lenguajes más comunes, finalmente se encuentra en inglés de forma única.

\subsection{Manual del usuario}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{IS-SSL}
\subsection{Requisitos de usuarios}
Los requisitos mínimos para poder hacer uso de \texttt{IS-SSL} son:
\begin{itemize}
\item Tener instalado Python 3.7+.
\item Tener instalado y configurado \texttt{PIP} o \texttt{Conda}.
\item Disponer de un editor de textos.
\item Tener instaladas las bibliotecas necesarias para su correcto funcionamiento.
\end{itemize}

\subsection{Instalación}

Por comodidad para el usuario, \texttt{IS-SSL} se ha dividido en dos bibliotecas, una formada por los algoritmos de selección de instancias, y una segunda por aquellos algoritmos de aprendizaje semi-supervisado.

El proceso de instalación de cualquiera de las dos bibliotecas es muy sencillo, siendo integrable en cualquier fichero de requerimientos, ya sea para \texttt{PIP} o \texttt{Conda}.

Las dos bibliotecas se encuentran publicadas en PyPI\footnote{\textit{Python Package Index} es un repositorio de \textit{software} para el lenguaje de programación de Python.} desde su versión 1.0, la cual fue una primea versión alpha estable con los primeros algoritmos publicados. 
La versión 3.0 es la versión estable (la final) que se ha publicado.

\imagenFlotante{../img/anexos/manual-usuario/PyPI-IS}{Vista de la biblioteca de algoritmos de selección de instancias en PyPI.}{PyPI-IS}
\imagenFlotante{../img/anexos/manual-usuario/PyPI-SSL}{Vista de la biblioteca de algoritmos de aprendizaje semi-supervisado en PyPI.}{PyPI-SSL}

Para realizar la instalación se deben seguir los siguientes pasos para cualquier LIB, LIB $\in \lbrace$ IS-DNX, SSL-DNX$\rbrace$.

\begin{enumerate}
\item Acceder a PyPi, desde~\cite{PyPI}.
\item Introducir en el campo de búsqueda <<LIB>>.
\item Seleccionar la biblioteca correspondiente de entre la lista mostrada.
\item Copiar el comando de instalación.
\item Abrir una terminal con soporte a Python y \texttt{PIP}.
\item Introducir el comando copiado.
\item En caso de que se nos pregunte si se quiere proceder con la descarga, indicar que sí con una S en caso de que esté en español, o con Y en el caso inglés/internacional.
\item Cuando finaliza la instalación, la biblioteca se encontrará lista para su uso.
\end{enumerate}

\imagenFlotante{../img/anexos/manual-usuario/PIP-IS}{Instalación de la biblioteca de selección de instancias.}{PIP-IS}
\imagenFlotante{../img/anexos/manual-usuario/PIP-SSL}{Instalación de la biblioteca de semi-supervisado.}{PIP-SSL}


\subsection{Manual del usuario}

A continuación se documentan las funcionalidades de las bibliotecas, desde su importación, a uso y especificación de los diferentes parámetros de entrada y salida esperados. A modo de resumen se puede destacar que todos los algoritmos siguen la misma estructura interna luego el aprendizaje y familizarización es relativamente rápido.

\subsubsection{Biblioteca de algoritmos de selección de instancias}
\textbf{Importar}

Para poder trabajar con los algoritmos de selección de instancias se deben de importar en el fichero en el que se quieran utilizar. Para ello se importan como cualquier otro paquete de Python, supongamos que queremos utilizar el algoritmo ENN, lo importaremos de la siguiente manera:

\texttt{from InstanceSelectionDNX import ENN} 

De esta forma podemos sustituir ENN por el algoritmo que deseemos de entre los disponibles y tenerlo a nuestra disposición para su uso.

Todos los algoritmos están codificados como \texttt{class} por lo tanto se debe de instanciar antes de poder hacer uso del mismo. 

\textbf{Uso}

Como se ha comentado al comienzo, todos los algoritmos poseen la misma estructura. Todos ellos poseen el método \texttt{filter} de tal manera que una vez se haya instanciado se podrá llamar al método y se obtendrá como resultado el conjunto de datos reducido.

Todos los algoritmos en su instanciación reciben aquellos parámetros que son necesarios para la configuración y su uso posterior, mientras que cuando se realiza el filtrado únicamente reciben el conjunto de datos dividido, por un lado los atributos y por otro lado la clase.

Tanto las entradas como las salidas deben ser objetos de tipo \texttt{DataFrame} de \texttt{Pandas}.

\begin{lstlisting}[language=python, caption={Ejemplo de uso de ENN}]]
from InstanceSelectionDNX import ENN
import pandas as pd

data = pd.DataFrame([[1, 2, 3, 4],
        [4, 3, 2, 1],
        [1, 2, 4, 3],
        [2, 1, 3, 4]])
target = pd.DataFrame([0, 0, 1, 1])

model = ENN(nearest_neighbors=3, power_parameter=2)

data_red, label_red = model.filter(data, target)
\end{lstlisting}

\subsubsection{Biblioteca de algoritmos de aprendizaje semi-supervisado}
\textbf{Importar}

De manera análoga a la otra biblioteca, importaremos el paquete y seleccionaremos cuál es el algoritmo que se desea utilizar, por ejemplo:

\texttt{from SemiSupervisedLearningDNX import TriTraining}

Pudiendo sustituir TriTraining por el algoritmo deseado.

Todos los algoritmos están codificados como \texttt{class} por lo tanto se debe de instanciar antes de poder hacer uso del mismo. 

\textbf{Uso}

Los algoritmos siguen la misma estructura interna que los propios de \texttt{Scikit-Learn}, por lo que una vez instanciados (con sus respectivos parámetros de configuración) bastará con llamar al método \texttt{fit} de cada uno de ellos, así como para predecir al método correspondiente, denominado \texttt{predict}.

\begin{itemize}
\item \textbf{\texttt{Fit}:} recibe como argumentos dos parámetros, las instancias y las etiquetas o clases, siendo -1 aquellas que se desconozcan y se quieran utilizar para entrenar el algoritmo.
\item \textbf{\texttt{Predict}:} recibe únicamente las instancias que se quieren etiquetar. Devuelve estas instancias etiquetadas.
\end{itemize}

Todas las entradas como las salidas deben ser objetos de tipo \texttt{DataFrame} de \texttt{Pandas}.

\begin{lstlisting}[language=Python, caption={Ejemplo de uso de IS-SSL}, label={lst:ejemplo}]
from SemiSupervisedLearningDNX import TriTraining
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.datasets import load_iris
	
model = TriTraining(
	random_state = 42,
	c1 = GaussianNB, c1_params = None,
	c2 = KNeighborsClassifier, c2_params = {n_neighbors: 2}
)
	
iris = load_iris()
X = iris['data']
y = iris['target']

X = pd.DataFrame(X), y = pd.DataFrame(y)
	
val = [True if i % 2 == 0 else False for i in range(len(y))]
y.loc[val] = -1

X, X_test, y, y_test = train_test_split(X.to_numpy(), y.to_numpy())

X = pd.DataFrame(X), y = pd.DataFrame(y)

model.fit(X, y)
y_pred = model.predict(X_test)
	
\end{lstlisting}